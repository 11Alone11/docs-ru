# \<script setup> {#script-setup}

`<script setup>` - это синтаксический сахар, обрабатываемый на этапе компиляции, для использования Composition API внутри однофайловых компонентов (SFC). Это рекомендуемый синтаксис при использовании однофайловых компонентов и Composition API. Он предоставляет ряд преимуществ по сравнению с обычным синтаксисом `<script>`:

- Более лаконичный код с меньшим количеством boilerplate-кода
- Возможность объявлять входные параметры и генерируемые события с использованием чистого TypeScript
- Лучшая производительность во время выполнения (шаблон компилируется в render-функцию в той же области видимости, без промежуточной прокси)
- Лучшая производительность IDE при определении типов (меньше работы для языкового сервера по извлечению типов из кода)

## Базовый синтаксис {#basic-syntax}

Чтобы использовать синтаксис, добавьте атрибут `setup` в секцию `<script>`:

```vue
<script setup>
console.log('привет script setup')
</script>
```

Код внутри компилируется как содержимое функции компонента `setup()`. Это означает, что в отличие от обычного `<script>`, который выполняется только один раз при первом импорте компонента, код внутри `<script setup>` будет **выполняться каждый раз при создании экземпляра компонента**.

### Привязки верхнего уровня будут доступны в шаблоне {#top-level-bindings-are-exposed-to-template}

При использовании `<script setup>` все привязки верхнего уровня (включая переменные, объявления функций и импорт), объявленные внутри `<script setup>`, будут доступны напрямую в шаблоне:

```vue
<script setup>
// переменная
const msg = 'Hello!'

// функции
function log() {
  console.log(msg)
}
</script>

<template>
  <button @click="log">{{ msg }}</button>
</template>
```

Импортированные функции раскрываются аналогичным образом. Это означает, что можно напрямую использовать импортированную вспомогательную функцию в выражениях шаблона, без необходимости объявлять её через опцию `methods`:

```vue
<script setup>
import { capitalize } from './helpers'
</script>

<template>
  <div>{{ capitalize('hello') }}</div>
</template>
```

## Реактивность {#reactivity}

Реактивное состояние должно быть явно создано с помощью [API реактивности](./reactivity-core.html). Аналогично значениям, возвращаемым функцией `setup()`, ref-ссылки автоматически разворачиваются при обращении к ним в шаблонах:

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>

<template>
  <button @click="count++">{{ count }}</button>
</template>
```

## Использование компонентов {#using-components}

Значения в области видимости `<script setup>` также могут быть использованы непосредственно в качестве имён тегов пользовательских компонентов:

```vue
<script setup>
import MyComponent from './MyComponent.vue'
</script>

<template>
  <MyComponent />
</template>
```

Считайте, что на `MyComponent` ссылаются как на переменную. Если вы использовали JSX, то ментальная модель здесь аналогична. Эквивалент kebab-case `<my-component>` работает и в шаблоне — однако для согласованности настоятельно рекомендуется использовать теги компонентов в PascalCase. Это также помогает отличить их от нативных пользовательских элементов.

### Динамические компоненты {#dynamic-components}

Поскольку на компоненты ссылаются на переменные, а не регистрируют их под строковыми ключами, то при использовании динамических компонентов внутри `<script setup>` следует использовать динамическую привязку с помощью `:is`:

```vue
<script setup>
import Foo from './Foo.vue'
import Bar from './Bar.vue'
</script>

<template>
  <component :is="Foo" />
  <component :is="someCondition ? Foo : Bar" />
</template>
```

Обратите внимание, как компоненты могут использоваться в качестве переменных в тернарном выражении.

### Рекурсивные компоненты {#recursive-components}

Однофайловые компоненты могут неявно ссылаться сами на себя с помощью имени файла. Например, файл с именем `FooBar.vue` может ссылаться на себя как `<FooBar/>` в своём шаблоне.

Обратите внимание, что это имеет более низкий приоритет, чем у импортированных компонентов. Если есть именованный импорт, который конфликтует с предполагаемым именем компонента от имени файла, то можно задать псевдоним для импортируемого:

```js
import { FooBar as FooBarChild } from './components'
```

### Компоненты с пространством имён {#namespaced-components}

Можно использовать теги компонентов с точками, например `<Foo.Bar>`, чтобы ссылаться на компоненты, вложенные в свойства объекта. Это полезно при импорте нескольких компонентов из одного файла:

```vue
<script setup>
import * as Form from './form-components'
</script>

<template>
  <Form.Input>
    <Form.Label>label</Form.Label>
  </Form.Input>
</template>
```

## Использование пользовательских директив {#using-custom-directives}

Пользовательские директивы, зарегистрированные глобально, работают как обычно. Локальные пользовательские директивы не нуждаются в явной регистрации в `<script setup>`, но они должны следовать схеме именования `vNameOfDirective`:

```vue
<script setup>
const vMyDirective = {
  beforeMount: (el) => {
    // сделать что-нибудь с элементом
  }
}
</script>
<template>
  <h1 v-my-directive>Какой-то заголовок</h1>
</template>
```

Если вы импортируете директиву из другого места, она может быть переименована в соответствии с требуемой схемой именования:

```vue
<script setup>
import { myDirective as vMyDirective } from './MyDirective.js'
</script>
```

## defineProps() и defineEmits() {#defineprops-defineemits}

Чтобы объявить `props` и `emits` с полной поддержкой вывода типов можно использовать API `defineProps` и `defineEmits`, которые автоматически доступны внутри `<script setup>`:

```vue
<script setup>
const props = defineProps({
  foo: String
})

const emit = defineEmits(['change', 'delete'])
// код setup
</script>
```

- `defineProps` и `defineEmits` - **макросы компилятора**, используемые только внутри `<script setup>`. Их не нужно импортировать и они будут компилироваться при обработке `<script setup>`.

- `defineProps` принимает то же значение, что и опция `props`, а `defineEmits` принимает то же значение, что и опция `emits`.

- `defineProps` и `defineEmits` предоставляют правильный вывод типов на основе переданных опций.

- Опции, передаваемые в `defineProps` и `defineEmits`, будут подняты из setup в область видимости модуля. Поэтому опции не могут ссылаться на локальные переменные, объявленные в области видимости setup. Это приведет к ошибке компиляции. Однако они _могут_ ссылаться на импортированные привязки, поскольку они также находятся в области видимости модуля.

При использовании TypeScript вы также можете [объявлять входные параметры и события с помощью аннотаций чистых типов](#typescript-only-features).

## defineExpose() {#defineexpose}

Компоненты, использующие `<script setup>`, **по умолчанию закрытые** - т.е. публичный экземпляр компонента, получаемый через ссылку в шаблоне или цепочки `$parent`, **не** объявляет доступа к каким-либо привязкам внутри `<script setup>`.

Для явного объявления свойств в компоненте `<script setup>` используйте макрос компилятора `defineExpose`:

```vue
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

defineExpose({
  a,
  b
})
</script>
```

Когда родитель получает экземпляр этого компонента через ссылку в шаблоне, полученный экземпляр будет иметь вид `{ a: number, b: number }` (ref-ссылки автоматически разворачиваются, как и для обычных экземпляров).

## `useSlots()` & `useAttrs()` {#useslots-useattrs}

Использование `slots` и `attrs` внутри `<script setup>` должно встречаться крайне редко, поскольку в шаблоне прямой доступ к ним можно получить через `$slots` и `$attrs`. В редких случаях, когда они всё же нужны, используйте вспомогательные методы `useSlots` и `useAttrs` соответственно:

```vue
<script setup>
import { useSlots, useAttrs } from 'vue'

const slots = useSlots()
const attrs = useAttrs()
</script>
```

`useSlots` и `useAttrs` - это runtime-функции, которые возвращают эквивалент `setupContext.slots` и `setupContext.attrs`. Они могут использоваться и в обычных функциях composition API.

## Использование вместе с обычной секцией `<script>` {#usage-alongside-normal-script}

`<script setup>` может использоваться вместе с обычной секцией `<script>`. Обычный `<script>` может понадобиться в случаях, когда необходимо:

- бъявление опций, которые не могут быть выражены в `<script setup>`, например `inheritAttrs` или пользовательские опции, добавляемые плагинами.
- Объявление именованных экспортов.
- Запуск side-эффектов или создание объектов, которые должны выполняться только один раз.

```vue
<script>
// обычный <script>, выполняется в области видимости модуля (только один раз)
runSideEffectOnce()

// объявление дополнительных опций
export default {
  inheritAttrs: false,
  customOptions: {}
}
</script>

<script setup>
// выполняется в области видимости setup() (для каждого экземпляра)
</script>
```

## `await` верхнего уровня {#top-level-await}

`await` верхнего уровня может быть использован внутри `<script setup>`. Полученный код будет скомпилирован как `async setup()`:

```vue
<script setup>
const post = await fetch(`/api/post/1`).then((r) => r.json())
</script>
```

Кроме того, ожидаемое выражение будет автоматически скомпилировано в формат, сохраняющий контекст текущего экземпляра компонента после `await`.

:::warning Примечание
`async setup()` должен использоваться в сочетании с `Suspense`, который в настоящее время является экспериментальной функцией. Мы планируем доработать и задокументировать его в одном из будущих релизов - но если вам интересно, то вы можете посмотреть его [тесты](https://github.com/vuejs/core/blob/main/packages/runtime-core/__tests__/components/Suspense.spec.ts), чтобы увидеть, как он работает.
:::

## Возможности только для TypeScript <sup class="vt-badge ts" /> {#typescript-only-features}

### Объявление типов для входных параметров/генерируемых событий {#type-only-props-emit-declarations}

Типы входных параметров и генерируемых событий можно объявить с помощью синтаксиса с передачей аргумента литерального типа в `defineProps` или `defineEmits`:

```ts
const props = defineProps<{
  foo: string
  bar?: number
}>()

const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
```

- В `defineProps` или `defineEmits` могут использовать только объявления во время runtime ИЛИ объявление типа. Использование обоих одновременно приведёт к ошибке компиляции.

- При использовании объявления типа, эквивалент объявления в runtime автоматически генерируется на основе статического анализа для устранения необходимости двойного объявления и обеспечении корректного поведения во время выполнения.

- When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.

  - В режиме разработки компилятор попытается вывести из типов соответствующую валидацию в runtime. Например, `foo: String` выводится из типа `foo: string`. Если тип будет ссылкой на импортированный тип, то результатом выведения будет `foo: null` (аналогичный типу any), так как компилятор не имеет информации о внешних файлах.

  - В режиме production компилятор сгенерирует массив форматов объявлений для уменьшения размера сборки (входные параметры здесь будут скомпилированы в `['foo', 'bar']`)

  - Выдаваемый код по-прежнему останется TypeScript с правильной типизацией, который может обрабатываться другими инструментами.

- В настоящее время для обеспечения корректного статического анализа, аргумент объявления типа должен быть одним из следующих:

  - Литерал типа
  - Ссылка на интерфейс или литерал типа в том же файле

  В настоящее время сложные типы и импорт типов из других файлов не поддерживается. Теоретически возможно что такая поддержка импортов появится в будущем.

### Значения входных параметров по умолчанию при использовании объявления типов {#default-props-values-when-using-type-declaration}

Один из недостатков объявления типов через `defineProps` в том, что нет возможности указать значения по умолчанию для входных параметров. Для решения этой проблемы создан макрос компилятора `withDefaults`:

```ts
export interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps<Props>(), {
  msg: 'привет',
  labels: () => ['один', 'два']
})
```

Это скомпилируется в эквиваленты опций `default` в runtime. Кроме того, `withDefaults` обеспечивает проверку типов для значений по умолчанию и гарантирует, что возвращаемый тип `props` будет с удалёнными необязательными флагами для свойств, у которых указаны значения по умолчанию.

## Ограничения {#restrictions}

Из-за разницы в семантике выполнения модулей код внутри `<script setup>` опирается на контекст однофайлового компонента. При переносе во внешние файлы `.js` или `.ts` это может привести к путанице как для разработчиков, так и для инструментов. Поэтому **`<script setup>`** не может быть использован с атрибутом `src`.
